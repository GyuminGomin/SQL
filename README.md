# SQL

```sqlOptimization 폴더 에서 실습을 진행할 수 있습니다.```

## 옵티마이저
`SQL의 실행계획을 수립하고, SQL을 실행하는 db 관리 시스템의 소프트웨어`

- 특징
    - data dictionary에 있는 오브젝트 통계, 시스템 통계 등의 정보를 사용해 예상되는 비용을 산정
    - 여러 개의 실행 계획 중에서 최저비용을 갖고 있는 계획을 선택해 SQL을 실행

> - 옵티마이저 실행 계획
>   - 개발자가 SQL을 실행하면 Parsing(SQL문법 검사, 구문 분석)을 실행해 SQL의 문법 검사 및 구문 분석을 수행
>   - 구문 분석이 완료되면 옵티마이저가 `규칙기반` 혹은 `비용기반`으로 실행 계획을 수립 (default = 비용 기반 : 통계정보를 활용해 최적의 실행 계획을 수립하는 것)
>   - 실행 계획 수립이 완료되면, 최종적으로 SQL을 실행하고 실행이 완료되면 데이터 인출(fetch)


```
- 옵티마이저 엔진 구조
    - Query Transformer
      SQL문을 효율적으로 실행하기 위해 옵티마이저가 변환
      SQL이 변환되어도 그 결과는 동일
    - Estimator
      통계정보를 사용해 SQL 실행비용을 계산
      총 비용은 최적의 실행 계획을 수립하기 위해서
    - Plan Generator
      SQL을 실행할 계획을 수립
```

```
- 옵티마이저 엔진
    규칙 기반 옵티마이저(Rule base Optimizer)는 실행 계획을 수립할 때 15 개의 우선순위를 기준으로 실행 계획을 수립
cf. 최신 오라클 버전은 비용 기반 옵티마이저를 기본적으로 사용

    우선순위    설명
        1       ROWID를 사용한 단일 행인 경우
        2       클러스터 조인에 의한 단일행인 경우
        3       유일하거나 기본키를 가진 해시 클러스터 키에 의한 단일 행인 경우
        4       유일하거나 기본키에 의한 단일 행인 경우
        5       클러스터 조인인 경우
        6       해시 클러스터 조인인 경우
        7       인덱스 클러스터 키인 경우
        8       복합 칼럼 인덱스인 경우
        9       단일 칼럼 인덱스인 경우
        10      인덱스가 구성된 칼럼에서 제한된 범위를 검색하는 경우
        11      인덱스가 구성된 칼럼에서 무제한 범위를 검색하는 경우
        12      정렬-병합(Sort Merge) 조인인 경우
        13      인덱스가 구성된 칼럼에서 MAX 혹은 MIN을 구하는 경우
        14      인덱스가 구성된 칼럼에서 ORDER BY를 실행하는 경우
        15      전체 테이블을 스캔(FULL TABLE SCAN)하는 경우

- 비용 기반 옵티마이저
    오브젝트 통계 및 시스템 통계를 사용해 총 비용을 계산
    총 비용이라는 것은 SQL문을 실행하기 위해 예상되는 소요시간 혹은 자원의 사용량을 의미
    총비용이 적은 쪽으로 실행 계획을 수립
cf. 비용 기반 옵티마이저에서 통계정보가 부적절한 경우 성능 저하가 발생가능
```

### 인덱스
`데이터를 빠르게 검색할 수 있는 방법을 제공`

- 테이블을 생성할 때, 기본키는 자동으로 인덱스가 만들어지고 인덱스의 이름은 SYSXXXX이다.
- 인덱스의 구조는 Root Block, Branch Block, Leaf Block으로 구성됨
    - Root Block : 인덱스 트리에서 가장 상위에 있는 노드
    - Branch Block : 다음 단계의 주소를 가지고 있는 포인터(Pointer)로 되어 있음
    - Leaf Block : 인덱스 키와 ROWID로 구성되고 인덱스 키는 정렬되어 저장되어 있음
        - Double Linked List 형태로 되어 있어 양방향 탐색이 가능
        - Leaf Block에서 인덱스 키를 읽으면 ROWID를 사용해 EMP 테이블의 행을 직접 읽을 수 있음

- 인덱스 생성
    - 인덱스 생성은 `CREATE INDEX` 문을 사용해 생성 가능
    - 인덱스를 생성할 때는 한 개 이상의 칼럼을 사용해 생성할 수 있음
    - 인덱스 키는 기본적으로 오름차순으로 정렬하고 'DESC' 구를 포함해 내림차순으로 정렬 가능
```
CREATE INDEX [인덱스 이름] EMP ON
    EMP (ENAME ASC, SAL DESC)
```
- 인덱스 스캔 
    - 인덱스 유일 스캔(Index Unique Scan)
        - 인덱스의 키 값이 중복되지 않는 경우, 해당 인덱스를 사용할 때 발생 됨.

    - 인덱스 범위 스캔
        - 특정 범위를 조회하는 where문을 사용할 경우 발생 (LIKE, BETWEEN) if 데이터 양이 적은 경우 인덱스 자체를 실행하지 않고 TABLE FULL SCAN이 될 수 있음.
        - 인덱스 범위 스캔은 인덱스의 Leaf Block의 특정 범위를 스캔한 것

    - 인덱스 전체 스캔
        - Index Full Scan은 인덱스에서 검색되는 인덱스 키가 많은 경우 Leaf Block의 처음부터 끝까지 전체를 읽어 들임.

- 실행 계획
```
select * from emp, dept
    where emp.deptno = dept.detpno
        and emp.deptno = 10;
이 구문의 실행계획을 살펴보면,
첫번째로 DEPT 테이블의 (SYSXXXX 인덱스를 유일하게 조회(INDEX UNIQUE SCAN))
두번째로 INDEX에서 DEPT 테이블 ROWID를 사용해 조회
세번째로 EMP 테이블을 전체 스캔(FULL SCAN)
마지막으로 DEPT 테이블과 EMP 테이블을 NESTED LOOP 조인을 해 최종 결과 반환
```

### Optimizer Join

- Nested Loop 조인
    - 하나의 테이블에서 데이터를 먼저 찾고 그 다음 테이블을 조인하는 방식으로 실행
    - 먼저 조회되는 테이블을 Outer Table, 그 다음 조회되는 테이블을 Inner Table
    - Outer Table의 크기가 작은 것을 먼저 찾는 것이 중요 (스캔되는 범위를 줄이기 위해)
    - Random Access가 발생하는데, 많이 발생되면 성능 지연 발생

- Sort Merge Join
    - 두 개의 테이블을 SORT_AREA 라는 메모리 공간에 모두 로드하고 SORT를 수행
    - 두 개의 테이블에 대해 SORT가 완료되면 두 개의 테이블을 병합
    - 정렬이 발생하기 때문에 데이터 양이 많아지면 성능 저하
    - 정렬 데이터양이 너무 많으면 정렬은 임시 영역에서 수행, 임시 영역은 디스크에 있기 때문에 성능이 급격히 저하될 수 있음.

- Hash Join
    - 두 개의 테이블 중 작은 테이블을 HASH 메모리에 로딩하고 두 개의 테이블의 조인 키를 사용해 해시 테이블을 생성
    - 해시 함수를 사용해 주소를 계산하고 해당 주소를 사용해 테이블을 조인하기 때문에 CPU 연산을 많이 사용
    - 선행 테이블이 충분히 메모리에 로딩되는 크기여야 함.
```
select /*+ ordered use_nl(b) */ *
    from emp a, dept b
    where a.deptno = b.deptno
        and a.deptno = 10;

ordered : from절에 기술한 테이블 순서대로 조인을 하는 힌트(hint)
use_nl : 강제로 Nested Join 수행
use_merge : 강제로 Sort Merge Join 수행
use_hash : 강제로 Hash Join 수행
```
