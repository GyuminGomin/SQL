# SQL

```sqlOptimization 폴더 에서 실습을 진행할 수 있습니다.```

## 옵티마이저
`SQL의 실행계획을 수립하고, SQL을 실행하는 db 관리 시스템의 소프트웨어`

- 특징
    - data dictionary에 있는 오브젝트 통계, 시스템 통계 등의 정보를 사용해 예상되는 비용을 산정
    - 여러 개의 실행 계획 중에서 최저비용을 갖고 있는 계획을 선택해 SQL을 실행

> - 옵티마이저 실행 계획
>   - 개발자가 SQL을 실행하면 Parsing(SQL문법 검사, 구문 분석)을 실행해 SQL의 문법 검사 및 구문 분석을 수행
>   - 구문 분석이 완료되면 옵티마이저가 `규칙기반` 혹은 `비용기반`으로 실행 계획을 수립 (default = 비용 기반 : 통계정보를 활용해 최적의 실행 계획을 수립하는 것)
>   - 실행 계획 수립이 완료되면, 최종적으로 SQL을 실행하고 실행이 완료되면 데이터 인출(fetch)


```
- 옵티마이저 엔진 구조
    - Query Transformer
      SQL문을 효율적으로 실행하기 위해 옵티마이저가 변환
      SQL이 변환되어도 그 결과는 동일
    - Estimator
      통계정보를 사용해 SQL 실행비용을 계산
      총 비용은 최적의 실행 계획을 수립하기 위해서
    - Plan Generator
      SQL을 실행할 계획을 수립
```

```
- 옵티마이저 엔진
    규칙 기반 옵티마이저(Rule base Optimizer)는 실행 계획을 수립할 때 15 개의 우선순위를 기준으로 실행 계획을 수립
cf. 최신 오라클 버전은 비용 기반 옵티마이저를 기본적으로 사용

    우선순위    설명
        1       ROWID를 사용한 단일 행인 경우
        2       클러스터 조인에 의한 단일행인 경우
        3       유일하거나 기본키를 가진 해시 클러스터 키에 의한 단일 행인 경우
        4       유일하거나 기본키에 의한 단일 행인 경우
        5       클러스터 조인인 경우
        6       해시 클러스터 조인인 경우
        7       인덱스 클러스터 키인 경우
        8       복합 칼럼 인덱스인 경우
        9       단일 칼럼 인덱스인 경우
        10      인덱스가 구성된 칼럼에서 제한된 범위를 검색하는 경우
        11      인덱스가 구성된 칼럼에서 무제한 범위를 검색하는 경우
        12      정렬-병합(Sort Merge) 조인인 경우
        13      인덱스가 구성된 칼럼에서 MAX 혹은 MIN을 구하는 경우
        14      인덱스가 구성된 칼럼에서 ORDER BY를 실행하는 경우
        15      전체 테이블을 스캔(FULL TABLE SCAN)하는 경우

- 비용 기반 옵티마이저
    오브젝트 통계 및 시스템 통계를 사용해 총 비용을 계산
    총 비용이라는 것은 SQL문을 실행하기 위해 예상되는 소요시간 혹은 자원의 사용량을 의미
    총비용이 적은 쪽으로 실행 계획을 수립
cf. 비용 기반 옵티마이저에서 통계정보가 부적절한 경우 성능 저하가 발생가능
```

### 인덱스
`데이터를 빠르게 검색할 수 있는 방법을 제공`

- 테이블을 생성할 때, 기본키는 자동으로 인덱스가 만들어지고 인덱스의 이름은 SYSXXXX이다.
- 인덱스의 구조는 Root Block, Branch Block, Leaf Block으로 구성됨
    - Root Block : 인덱스 트리에서 가장 상위에 있는 노드
    - Branch Block : 다음 단계의 주소를 가지고 있는 포인터(Pointer)로 되어 있음
    - Leaf Block : 인덱스 키와 ROWID로 구성되고 인덱스 키는 정렬되어 저장되어 있음
        - Double Linked List 형태로 되어 있어 양방향 탐색이 가능
        - Leaf Block에서 인덱스 키를 읽으면 ROWID를 사용해 EMP 테이블의 행을 직접 읽을 수 있음

- 인덱스 생성
    - 인덱스 생성은 `CREATE INDEX` 문을 사용해 생성 가능
    - 인덱스를 생성할 때는 한 개 이상의 칼럼을 사용해 생성할 수 있음
    - 인덱스 키는 기본적으로 오름차순으로 정렬하고 'DESC' 구를 포함해 내림차순으로 정렬 가능
```
CREATE INDEX [인덱스 이름] EMP ON
    EMP (ENAME ASC, SAL DESC)
```
- 인덱스 스캔 
    - 인덱스 유일 스캔(Index Unique Scan)
        - 인덱스의 키 값이 중복되지 않는 경우, 해당 인덱스를 사용할 때 발생 됨.

    - 인덱스 범위 스캔
        - 특정 범위를 조회하는 where문을 사용할 경우 발생 (LIKE, BETWEEN) if 데이터 양이 적은 경우 인덱스 자체를 실행하지 않고 TABLE FULL SCAN이 될 수 있음.
        - 인덱스 범위 스캔은 인덱스의 Leaf Block의 특정 범위를 스캔한 것

    - 인덱스 전체 스캔
        - Index Full Scan은 인덱스에서 검색되는 인덱스 키가 많은 경우 Leaf Block의 처음부터 끝까지 전체를 읽어 들임.

- 실행 계획
```
select * from emp, dept
    where emp.deptno = dept.detpno
        and emp.deptno = 10;
이 구문의 실행계획을 살펴보면,
첫번째로 DEPT 테이블의 (SYSXXXX 인덱스를 유일하게 조회(INDEX UNIQUE SCAN))
두번째로 INDEX에서 DEPT 테이블 ROWID를 사용해 조회
세번째로 EMP 테이블을 전체 스캔(FULL SCAN)
마지막으로 DEPT 테이블과 EMP 테이블을 NESTED LOOP 조인을 해 최종 결과 반환
```

### Optimizer Join

- Nested Loop 조인
    - 하나의 테이블에서 데이터를 먼저 찾고 그 다음 테이블을 조인하는 방식으로 실행
    - 먼저 조회되는 테이블을 Outer Table, 그 다음 조회되는 테이블을 Inner Table
    - Outer Table의 크기가 작은 것을 먼저 찾는 것이 중요 (스캔되는 범위를 줄이기 위해)
    - Random Access가 발생하는데, 많이 발생되면 성능 지연 발생

- Sort Merge Join
    - 두 개의 테이블을 SORT_AREA 라는 메모리 공간에 모두 로드하고 SORT를 수행
    - 두 개의 테이블에 대해 SORT가 완료되면 두 개의 테이블을 병합
    - 정렬이 발생하기 때문에 데이터 양이 많아지면 성능 저하
    - 정렬 데이터양이 너무 많으면 정렬은 임시 영역에서 수행, 임시 영역은 디스크에 있기 때문에 성능이 급격히 저하될 수 있음.

- Hash Join
    - 두 개의 테이블 중 작은 테이블을 HASH 메모리에 로딩하고 두 개의 테이블의 조인 키를 사용해 해시 테이블을 생성
    - 해시 함수를 사용해 주소를 계산하고 해당 주소를 사용해 테이블을 조인하기 때문에 CPU 연산을 많이 사용
    - 선행 테이블이 충분히 메모리에 로딩되는 크기여야 함.
```
select /*+ ordered use_nl(b) */ *
    from emp a, dept b
    where a.deptno = b.deptno
        and a.deptno = 10;

ordered : from절에 기술한 테이블 순서대로 조인을 하는 힌트(hint)
use_nl : 강제로 Nested Join 수행
use_merge : 강제로 Sort Merge Join 수행
use_hash : 강제로 Hash Join 수행
```


## 문제적 읽기
### 슈퍼타입과 서브타입 변환 방법의 종류
- OneToOne Type
    - 슈퍼타입과 서브타입을 개별 테이블로 도출함
    - 테이블의 수가 많아 조인이 발생하고 관리가 어려움
- Plus Type
    - 슈퍼타입과 서브타입 테이블로 도출
    - 조인이 발생하고 관리가 어려움
- Single Type
    - 슈퍼타입과 서브타입을 하나의 테이블로 도출
    - 조인 성능이 좋고 관리가 편리하지만, 입출력 성능이 나쁨

### 카디널리티 계산하는 식
- 카디널리티는 두 개의 엔터티에서 관계에 참여하는 수이다. 1:1, 1:N, M:N이 있다.
- 카디널리티 계산식 : 선택도 x 전체 레코드 수

### 제 3 정규화
- 이행 함수 종속성 제거로 칼럼 간에 종속성이 발생하면, 테이블을 분할
    - 기본키를 제외하고 칼럼 간 종속성이 발생하면, 테이블을 분할

> 제 2 정규화
    - 복합 인스턴스에 대해 각 인스턴스의 종속성 중복을 제거  
> 제 1 정규화
    - 속성의 중복값을 제거

### CUBE 함수
- CUBE 함수의 인자로 전달된 칼럼에 대해 모든 결합 가능한 집계를 계산
- GROUPING SETS 함수는 GROUP BY에 나오는 칼럼의 순서와 관계없이 다양한 소계를 만들 수 있음
    즉, 칼럼의 순서와 관계없이 개별적으로 모두 처리

### 계층형 쿼리
- connect by 키워드
    - level : 검색 항목의 깊이를 의미함. 즉, 계층 구조에서 가장 상위 레벨이 1
    - connect_by_root : 계층 구조에서 가장 최상위 값을 표시
    - connect_by_isleaf : 계층 구조에서 가장 최하위 값
    - sys_connect_by_path : 계층 구조의 전체 전개 경로 표시
    - nocycle : 순환 구조가 발생 지점까지만 전개
    - connect_by_iscycle : 순환 구조 발생 지점을 표시

### 분산 데이터베이스의 투명성
- 분할, 위치, 지역사상, 중복 투명성이 존재함.

### LEAD
`LEAD(속성 값, 몇번째 뒤의 값, 없을 때 채울 값)`

### LPAD
`LPAD(속성 값, 지정할 길이, 공백을 채울 문자)`

### COALESCE coalesce
`COALESCE(숫자, 숫자, 숫자....) 가장 앞에서부터 null이 아닌 값 출력`
ex. COALESCE(null, 100, 200) -> 100

### nullif
`NULLIF(값,값) 두개의 값이 같으면 null 다르면 가장 앞에 있는 값 출력`
ex. NULLIF(1,1) -> null, NULLIF(1,2) -> 1

### 파티션
- Range Partition : 데이터 값의 범위를 기준으로 파티션 수행
- List Partition : 특정 값을 지정해 파티션 수행
    - 파티셔닝 할 항목을 관리자가 직접 지정하는 방법으로 제품에 대해 파티션을 생성함
    - 데이터 보관 주기에 따라 쉽게 데이터를 삭제할 수 없음.
- Hash Partition : 해시 함수를 적용해 파티션 수행
- Composite Partition : 범위와 해시를 복합적으로 사용해 파티션 수행

### 속성의 특성
- 속성의 종류
    - 기본 속성 : 가장 일반적인 것으로 일련번호, 코드 데이터처럼 다른 속성에서 계산하거나 영향을 받은 것을 제외한 모든 속성
    - 설계 속성 : 데이터 모델링 과정에서 생성되는 속성 ex. 일련번호와 같이 설계 과정에서 만들어지는 속성
    - 파생 속성 : 다른 속성으로부터 영향을 받아서 생성되는 속성, ex. 직원별 급여합계, 월별 생산량 등

### 엔터티의 특징
- 기본 엔터티 : 키엔터티라고하고 다른 엔터티로부터 영향을 받지 않고, 독립적으로 생성되는 엔터티(고객, 상품, 부서)
- 중심 엔터티 : 기본 엔터티로부터 발생되고 행위 엔터티를 생성하는 것(계좌, 주문, 취소, 체결)
- 행위 엔터티 : 2개 이상의 엔터티로부터 발생 (주문이력, 체결이력)

### B-Tree 인덱스
`분기를 수행하는 브랜치 블록, 인덱스를 구성하는 칼럼값을 가지는 리프 블록으로 구성`

### Unique 제약 조건
`칼럼에 중복된 값을 허용하지 않지만, Null 값은 포함`




`다음 중 계층형 쿼리에 대한 설명으로 옳지 않은 것은?`
1. Prior 자식 = 부모 형태를 사용하면 계층 구조에서 순방향 전개를 수행한다.
2. 계층형 쿼리는 계층형 형태로 데이터를 질의할 때 사용된다.
3. Connect by는 부모 자식을 설명하는 것이다. (x) -> 부모 계층형 쿼리에서 부모 노드와 자식 노드 사이의 특정한 관계를 나타내는 데 사용
4. connect_by_isleaf에서 해당 데이터가 리프 데이터면 1, 그렇지 않으면 0을 반환한다.

`사용자 A가 어떤 릴레이션에 대한 SELECT 권한을 WITH GRANT OPTION과 함께 사용자 B에게 허가하고, B는 C에게, C는 D에게 허가했을 때, 사용자 A가 B의 SELECT 권한을 취소시키면 C와 D는 어떻게 되는가?`
- C와 D의 권한이 취소된다.

`엔터티 간의 관계 중 비식별 관계에 대한 설명으로 올바르지 않은 것은?`
1. 약한 연결 관계를 표현
2. 엔터티 간의 관계를 점선으로 표현
3. 부모 쪽의 관계 참여가 선택적 관계
4. 반드시 부모 엔터티에 종속 (x) -> 식별관계

`정규화를 수행하지 않고 엔터티에 데이터를 입력할 때 불필요한 데이터를 같이 입력하거나 삭제하면 다른 데이터까지 같이 삭제되는 문제는?`
- 이상현상
    - 삽입 이상현상, 갱신 이상현상, 삭제 이상현상이 존재

`데이터베이스 파티션 기법 중 날짜 및 숫자처럼 연속된 값을 기준으로 만드는 파티션 기법은?`
- Range Partition